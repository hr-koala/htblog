import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a,o as t}from"./app-C9dI6X0b.js";const r={};function n(o,l){return t(),i("div",null,l[0]||(l[0]=[a('<h2 id="一、缓存" tabindex="-1"><a class="header-anchor" href="#一、缓存"><span>一、缓存</span></a></h2><p><strong>强缓存</strong>（不需要发送 <code>HTTP</code> 请求）</p><ol><li><code>Expires</code> （过期时间）存在于响应头中。</li><li><code>Cache-Control</code>（存在与请求头和响应头中）</li></ol><ul><li>max-age</li><li>public</li><li>private</li><li>no-cache</li><li>no-store</li><li>s-maxage</li></ul><h3 id="协商缓存-需要发送-http-请求-在请求头中携带缓存-tag-在服务器端决定是否使用缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存-需要发送-http-请求-在请求头中携带缓存-tag-在服务器端决定是否使用缓存"><span>协商缓存（需要发送 HTTP 请求，在请求头中携带缓存 tag，在服务器端决定是否使用缓存）</span></a></h3><ol><li><code>Last-Modified</code> （浏览器第二次发送请求会在请求头中携带：If-Modified-Since）304：用户直接使用缓存</li><li><code>ETag</code> 文件生成的唯一标识（浏览器第二次发送请求会在请求头中携带：If-None-Match）304：用户直接使用缓存</li></ol><h3 id="缓存地址" tabindex="-1"><a class="header-anchor" href="#缓存地址"><span>缓存地址：</span></a></h3><ol><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ol><h2 id="二、浏览器本地存储" tabindex="-1"><a class="header-anchor" href="#二、浏览器本地存储"><span>二、浏览器本地存储</span></a></h2><p>浏览器本地存储：</p><ol><li><code>Cookie</code></li><li><code>WebStorage</code>（localStorage、sessionStorage）</li><li><code>IndexDB</code></li></ol><h2 id="三、从输入-url-到页面呈现发生了什么" tabindex="-1"><a class="header-anchor" href="#三、从输入-url-到页面呈现发生了什么"><span>三、从输入 URL 到页面呈现发生了什么？</span></a></h2><h3 id="网络请求和响应" tabindex="-1"><a class="header-anchor" href="#网络请求和响应"><span>网络请求和响应：</span></a></h3><ol><li>构建请求行 GET / HTTP/1.1，同时带上请求头和请求体</li><li>查找强缓存</li><li><code>DNS</code> 解析</li><li><code>TCP</code> 连接</li><li>网络响应</li></ol><ul><li>响应行：HTTP/1.1 200 OK</li><li>响应头：Set-Cookie、Date、Server、Cache-Control、Connection、Content-Encoding</li><li>响应体</li></ul><div class="language-ts line-numbers-mode" data-highlighter="shiki" data-ext="ts" data-title="ts" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Content</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Type</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">text</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">html</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="解析算法" tabindex="-1"><a class="header-anchor" href="#解析算法"><span>解析算法：</span></a></h3><ol><li>构建 <code>DOM</code> 树 生成方便操作的数据结构</li><li>样式计算 <code>CSS</code> 文本-&gt;结构化对象（styleSheets）</li></ol><ul><li>标准化样式属性</li><li>计算每个节点的样式 继承、层叠</li></ul><ol start="3"><li>生成布局树 <code>DOM</code> 树+<code>DOM</code> 样式 -&gt; 布局树（确定元素的位置）</li></ol><h3 id="渲染过程" tabindex="-1"><a class="header-anchor" href="#渲染过程"><span>渲染过程：</span></a></h3><ol><li>建立图层树 解决复杂场景：3D 动画呈现的变换效果、元素含有层叠上下文时如何控制显示和隐藏等 <ul><li>节点的图层默认属于父节点的图层（合称为合成层）</li><li>合称方法：显式合称和隐式合成</li><li>显示合称： 1. 层叠上下文 2. 需要裁剪的地方</li></ul></li><li>生成绘制列表</li><li>生成图块并删格化</li><li>显示器显示内容</li></ol><h2 id="四、-回流和重绘" tabindex="-1"><a class="header-anchor" href="#四、-回流和重绘"><span>四、 回流和重绘</span></a></h2><h3 id="回流" tabindex="-1"><a class="header-anchor" href="#回流"><span>回流</span></a></h3><p>触发条件：</p><ul><li>width、height、padding、margin、left、right、border</li><li>节点增删</li><li>读写 offset、scroll、client</li><li>调用 window.getComputedStyle<br> 需要重新生成 DOM 树，解析和合成全部需要重新走一遍</li></ul><h3 id="重绘-repain" tabindex="-1"><a class="header-anchor" href="#重绘-repain"><span>重绘（repain）：</span></a></h3><p><strong>window.requestAnimationFrame</strong></p><p>触发条件：样式发生变化，并没有影响几何属性</p><p>跳过了生成布局树和建图层树的过程。</p><h2 id="五、-xss" tabindex="-1"><a class="header-anchor" href="#五、-xss"><span>五、 XSS</span></a></h2><p>跨站脚本，浏览器中执行恶意脚本</p><ul><li>存储型（存储到了服务器的数据库上）</li><li>反射性（作为网络请求的一部分）</li><li>文档型（并不会经过服务器，在数据传输过程劫持到网络数据包，然后修改里面的 HTML 文档）</li></ul><h3 id="防范措施" tabindex="-1"><a class="header-anchor" href="#防范措施"><span>防范措施：</span></a></h3><ol><li>对用户输入进行转码、过滤</li><li>利用 CSP（浏览器内容安全策略，服务器决定加载哪些功能） <ul><li>限制其他域下的资源加载</li><li>禁止向其它域提交数据</li></ul></li><li>利用 HttpOnly</li></ol><h2 id="五、-csrf" tabindex="-1"><a class="header-anchor" href="#五、-csrf"><span>五、 CSRF</span></a></h2><p>CSRF：跨站请求伪造</p><h3 id="方式" tabindex="-1"><a class="header-anchor" href="#方式"><span>方式：</span></a></h3><p>诱导用户点击链接，打开黑客的网站，利用用户目前的登录状态发起跨站请求。</p><ol><li>自动发起 GET 请求。 <code>&lt;img src=&quot;xxx.com?user=aaa&quot;&gt;</code></li><li>自动发起 POST 请求。</li><li>诱导点击发送 GET 请求。</li></ol><h3 id="防范策略" tabindex="-1"><a class="header-anchor" href="#防范策略"><span>防范策略：</span></a></h3><ol><li>利用 <code>Cookie</code> 的 SameSit 属性。</li></ol><ul><li>Strict。完全禁止第三方携带 Cookie</li><li>Lax。GET 请求可以。</li><li>None。不限制</li></ul><ol start="2"><li>验证来源站点。 请求头：<strong>Origin</strong>和<strong>Referer</strong>。</li><li><code>CSRF Token</code>。</li></ol><ul><li>浏览器发送请求时，服务器生成字符串将其植入返回的页面中。</li></ul><h2 id="六、-https" tabindex="-1"><a class="header-anchor" href="#六、-https"><span>六、 HTTPS</span></a></h2><p>HTTP 是<strong>明文传输</strong>，HTTP 数据 -&gt; TCP 层 -&gt; WIFI 路由器 -&gt; 运营商 -&gt; 服务器，中间过程可能被中间人攻击。</p><p>HTTPS 在 HTTP 和 TCP 之间建立了一个<strong>安全层</strong>，将数据<strong>加密</strong>之后传给 TCP，TCP 也必须将数据<strong>解密</strong>，才能传给上面的 HTTP。</p><p>安全层的核心就是对数据加解密。</p><ol><li>对称加密。加密和解密用的相同密钥。</li></ol><ul><li>浏览器 -&gt; 服务器： client_random + 加密方法列表</li><li>服务器 -&gt; 浏览器： server_random + 加密方法</li><li>用加密方法把这两个随机数混合起来，作为<strong>暗号</strong><br> 因为用的相同密钥，这个加密方法既能加密也能解密拿到数据。</li></ul><ol start="2"><li>非对称加密。有 A、B 两把密钥，A 可以解 B，B 也可以解 A。服务器有两把钥匙：公钥和密钥。</li></ol><ul><li>浏览器 -&gt; 服务器： client_random + 加密方法列表</li><li>服务器 -&gt; 浏览器： server_random + 加密方法 + 公钥</li><li>浏览器对用公钥对 clien_random 和 server_random 进行加密，生成通信<strong>暗号</strong>。<br> 中间人拿到浏览器的数据，因为没有私钥，无法解密，保证了数据安全。<br> 但相应的问题是：服务器 -&gt; 浏览器数据，只能用私钥加密，中间人拿到公钥，就能进行解密了。</li></ul><ol start="3"><li>非对称 + 对称结合。</li></ol><ul><li>浏览器 -&gt; 服务器： client_random + 加密方法列表</li><li>服务器 -&gt; 浏览器： server_random + 加密方法 + 公钥</li><li>浏览器生成随机数<strong>pre_random</strong>，并用公钥加密，传给服务器。</li><li>服务器用私钥解密，得到<strong>pre_random</strong></li><li>然后浏览器和服务器用一样的公钥进行通信，即对称加密。<br> 中间人没有私钥，拿不到<strong>pre_random</strong>，无法生成最终的密钥。</li></ul><h3 id="添加数字证书" tabindex="-1"><a class="header-anchor" href="#添加数字证书"><span>添加数字证书</span></a></h3><p>目的： 让服务器证明自己的身份。</p><p>向 CA 认证，会给服务器颁发数字证书。</p><p>作用：</p><ol><li>服务器向浏览器证明自己的身份</li><li>把公钥传给服务器（数字证书包含了公钥）</li></ol><p>读取证书中的明文内容，CA 会保存一个 Hash 函数，这个函数计算明文得到信息 A，公钥解密明文得到信息 B，两份信息对比一致认证合法。</p>',61)]))}const c=e(r,[["render",n],["__file","browser.html.vue"]]),d=JSON.parse('{"path":"/browser/browser.html","title":"browser 的理解","lang":"zh-CN","frontmatter":{"title":"browser 的理解","date":"2025-02-26T00:00:00.000Z","article":false,"description":"一、缓存 强缓存（不需要发送 HTTP 请求） Expires （过期时间）存在于响应头中。 Cache-Control（存在与请求头和响应头中） max-age public private no-cache no-store s-maxage 协商缓存（需要发送 HTTP 请求，在请求头中携带缓存 tag，在服务器端决定是否使用缓存） Last-M...","head":[["meta",{"property":"og:url","content":"https://hr-koala.github.io/htblog/htblog/browser/browser.html"}],["meta",{"property":"og:site_name","content":"博客和随笔"}],["meta",{"property":"og:title","content":"browser 的理解"}],["meta",{"property":"og:description","content":"一、缓存 强缓存（不需要发送 HTTP 请求） Expires （过期时间）存在于响应头中。 Cache-Control（存在与请求头和响应头中） max-age public private no-cache no-store s-maxage 协商缓存（需要发送 HTTP 请求，在请求头中携带缓存 tag，在服务器端决定是否使用缓存） Last-M..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-26T12:39:55.000Z"}],["meta",{"property":"article:published_time","content":"2025-02-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-26T12:39:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"browser 的理解\\",\\"description\\":\\"一、缓存 强缓存（不需要发送 HTTP 请求） Expires （过期时间）存在于响应头中。 Cache-Control（存在与请求头和响应头中） max-age public private no-cache no-store s-maxage 协商缓存（需要发送 HTTP 请求，在请求头中携带缓存 tag，在服务器端决定是否使用缓存） Last-M...\\"}"]]},"headers":[{"level":2,"title":"一、缓存","slug":"一、缓存","link":"#一、缓存","children":[{"level":3,"title":"协商缓存（需要发送 HTTP 请求，在请求头中携带缓存 tag，在服务器端决定是否使用缓存）","slug":"协商缓存-需要发送-http-请求-在请求头中携带缓存-tag-在服务器端决定是否使用缓存","link":"#协商缓存-需要发送-http-请求-在请求头中携带缓存-tag-在服务器端决定是否使用缓存","children":[]},{"level":3,"title":"缓存地址：","slug":"缓存地址","link":"#缓存地址","children":[]}]},{"level":2,"title":"二、浏览器本地存储","slug":"二、浏览器本地存储","link":"#二、浏览器本地存储","children":[]},{"level":2,"title":"三、从输入 URL 到页面呈现发生了什么？","slug":"三、从输入-url-到页面呈现发生了什么","link":"#三、从输入-url-到页面呈现发生了什么","children":[{"level":3,"title":"网络请求和响应：","slug":"网络请求和响应","link":"#网络请求和响应","children":[]},{"level":3,"title":"解析算法：","slug":"解析算法","link":"#解析算法","children":[]},{"level":3,"title":"渲染过程：","slug":"渲染过程","link":"#渲染过程","children":[]}]},{"level":2,"title":"四、 回流和重绘","slug":"四、-回流和重绘","link":"#四、-回流和重绘","children":[{"level":3,"title":"回流","slug":"回流","link":"#回流","children":[]},{"level":3,"title":"重绘（repain）：","slug":"重绘-repain","link":"#重绘-repain","children":[]}]},{"level":2,"title":"五、 XSS","slug":"五、-xss","link":"#五、-xss","children":[{"level":3,"title":"防范措施：","slug":"防范措施","link":"#防范措施","children":[]}]},{"level":2,"title":"五、 CSRF","slug":"五、-csrf","link":"#五、-csrf","children":[{"level":3,"title":"方式：","slug":"方式","link":"#方式","children":[]},{"level":3,"title":"防范策略：","slug":"防范策略","link":"#防范策略","children":[]}]},{"level":2,"title":"六、 HTTPS","slug":"六、-https","link":"#六、-https","children":[{"level":3,"title":"添加数字证书","slug":"添加数字证书","link":"#添加数字证书","children":[]}]}],"git":{"createdTime":1740323465000,"updatedTime":1740573595000,"contributors":[{"name":"hr-koala","username":"hr-koala","email":"htong890@outlook.com","commits":4,"url":"https://github.com/hr-koala"}]},"readingTime":{"minutes":4.79,"words":1436},"filePathRelative":"browser/browser.md","localizedDate":"2025年2月26日","excerpt":"<h2>一、缓存</h2>\\n<p><strong>强缓存</strong>（不需要发送 <code>HTTP</code> 请求）</p>\\n<ol>\\n<li><code>Expires</code> （过期时间）存在于响应头中。</li>\\n<li><code>Cache-Control</code>（存在与请求头和响应头中）</li>\\n</ol>\\n<ul>\\n<li>max-age</li>\\n<li>public</li>\\n<li>private</li>\\n<li>no-cache</li>\\n<li>no-store</li>\\n<li>s-maxage</li>\\n</ul>\\n<h3>协商缓存（需要发送 HTTP 请求，在请求头中携带缓存 tag，在服务器端决定是否使用缓存）</h3>","autoDesc":true}');export{c as comp,d as data};
