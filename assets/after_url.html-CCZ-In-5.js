import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as c,o as i}from"./app-DBPnYIbX.js";const a={};function d(l,e){return i(),t("div",null,e[0]||(e[0]=[c('<h2 id="面试官-说说地址栏输入-url-敲下回车后发生了什么" tabindex="-1"><a class="header-anchor" href="#面试官-说说地址栏输入-url-敲下回车后发生了什么"><span>面试官：说说地址栏输入 URL 敲下回车后发生了什么?</span></a></h2><figure><img src="https://static.vue-js.com/11bf1f20-bdf4-11eb-85f6-6fac77c0c9b3.png" alt="址栏输入 URL" tabindex="0" loading="lazy"><figcaption>址栏输入 URL</figcaption></figure><h3 id="一、简单分析" tabindex="-1"><a class="header-anchor" href="#一、简单分析"><span>一、简单分析</span></a></h3><p>从前端的角度分析，从输入 <code>URL</code>到回车后发生的行为如下：</p><ul><li>URL 解析</li><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 请求</li><li>响应请求</li><li>页面渲染</li></ul><h3 id="二、详细分析" tabindex="-1"><a class="header-anchor" href="#二、详细分析"><span>二、详细分析</span></a></h3><h4 id="url-解析" tabindex="-1"><a class="header-anchor" href="#url-解析"><span>URL 解析</span></a></h4><p>首先判断你输入的是一个合法的<code> URL</code> 还是一个待搜索的关键词，并且根据你输入的内容进行对应操作</p><p><code>URL</code>的解析第过程中的第一步，一个<code>url</code>的结构解析如下：</p><figure><img src="https://static.vue-js.com/27a0c690-bdf4-11eb-ab90-d9ae814b240d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="dns-查询" tabindex="-1"><a class="header-anchor" href="#dns-查询"><span>DNS 查询</span></a></h4><p>将域名解析成 <code>IP</code> 地址</p><p>整个查询过程如下图所示：</p><figure><img src="https://static.vue-js.com/330fb770-bdf4-11eb-85f6-6fac77c0c9b3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>最终，获取到了域名对应的目标服务器<code>IP</code>地址</p><h4 id="tcp-连接" tabindex="-1"><a class="header-anchor" href="#tcp-连接"><span>TCP 连接</span></a></h4><p>在之前文章中，了解到<code>tcp</code>是一种面向有连接的传输层协议</p><p>在确定目标服务器服务器的<code>IP</code>地址后，则经历三次握手建立<code>TCP</code>连接，流程如下：</p><figure><img src="https://static.vue-js.com/ad750790-bdf4-11eb-85f6-6fac77c0c9b3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="发送-http-请求" tabindex="-1"><a class="header-anchor" href="#发送-http-请求"><span>发送 http 请求</span></a></h4><p>当建立<code>tcp</code>连接之后，就可以在这基础上进行通信，浏览器发送 <code>http</code> 请求到目标服务器</p><p>请求的内容包括：</p><ul><li>请求行</li><li>请求头</li><li>请求主体</li></ul><figure><img src="https://static.vue-js.com/bbcb60f0-bdf4-11eb-ab90-d9ae814b240d.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="响应请求" tabindex="-1"><a class="header-anchor" href="#响应请求"><span>响应请求</span></a></h4><p>当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个<code>HTTP</code>响应消息，包括：</p><ul><li>状态行</li><li>响应头</li><li>响应正文</li></ul><figure><img src="https://static.vue-js.com/c5fe0140-bdf4-11eb-ab90-d9ae814b240d.png" alt="响应请求" tabindex="0" loading="lazy"><figcaption>响应请求</figcaption></figure><p>在服务器响应之后，由于现在<code>http</code>默认开始长连接<code>keep-alive</code>，当页面关闭之后，<code>tcp</code>链接则会经过四次挥手完成断开</p><h4 id="页面渲染" tabindex="-1"><a class="header-anchor" href="#页面渲染"><span>页面渲染</span></a></h4><p>当浏览器接收到服务器响应的资源后，首先会对资源进行解析：</p><ul><li>查看响应头的信息，根据不同的指示做对应处理，比如<strong>重定向</strong>，存储 <code>cookie</code>，<strong>解压 gzip</strong>，<strong>缓存资源</strong>等等</li><li>查看响应头的 <code>Content-Type</code> 的值，根据不同的资源类型采用不同的解析方式</li></ul><p>关于页面的渲染过程如下：</p><p>浏览器接收到首屏 html，开始渲染</p><ul><li>解析 <code>HTML</code>，构建 <code>DOM</code> 树</li><li>解析 <code>CSS</code> ，生成 <code>CSS</code> 规则树</li><li>合并 <code>DOM</code> 树和 <code>CSS</code> 规则，生成 <code>render</code> 树</li><li>布局 <code>render</code> 树（ <code>Layout</code> / <code>reflow</code> ），负责各元素尺寸、位置的计算</li><li>绘制 <code>render</code> 树（ <code>paint</code> ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 <code>GPU</code>，<code>GPU</code> 会将各层合成（ <code>composite</code> ），显示在屏幕上</li></ul><figure><img src="https://static.vue-js.com/db7bddd0-bdf4-11eb-85f6-6fac77c0c9b3.png" alt="页面渲染" tabindex="0" loading="lazy"><figcaption>页面渲染</figcaption></figure><p>从上面步骤可以看出，影响性能的主要是<code>加载</code>和<code>渲染</code>。此外还有运行时的性能：<code>脚本执行</code>。</p><h3 id="加载优化" tabindex="-1"><a class="header-anchor" href="#加载优化"><span>加载优化</span></a></h3><p>资源加载（网络层面）方面的性能优化主要是 <strong><em>减小资源体积，减少请求数量</em></strong></p><h4 id="减小资源体积" tabindex="-1"><a class="header-anchor" href="#减小资源体积"><span>减小资源体积</span></a></h4><p>减小资源体积最有效的方法就是压缩。比如 js 混淆压缩，html 压缩，图片压缩等。再加上 Gzip 神器，再压缩三分之一以上不是问题</p><ul><li>实际项目中体积大的基本上是图片，字体这些资源，代码体积反而没那么大 <ul><li>注意 <strong><em>图片格式</em></strong>，png 格式无损压缩</li><li><strong>字体的优化</strong>，在一些场景下，可以直接抽出需要的字体，文件立马小很多</li><li><strong><em>按需加载</em></strong>，在组件库、babel-polyfill 等场景应用比较多</li></ul></li></ul><h4 id="减少请求数量" tabindex="-1"><a class="header-anchor" href="#减少请求数量"><span>减少请求数量</span></a></h4><p>减少请求数量，常用的方法就是 **<em>缓存</em>**和 <strong><em>合并请求</em></strong></p><ul><li>效果最顶的就是<strong>浏览器缓存</strong>。通过 <code>expires</code> 和 <code>Cache-Control</code> 进行<strong>强缓存</strong>；通过 <code>Last-Modified</code> 和 <code>ETag</code> 进行<strong>协商缓存</strong>，就能缓存大部分资源文件。基本上就剩文档（html）和接口的请求了。</li><li>第二种缓存是 <code>CDN</code>。<code>CDN</code> 是一组分布在各个地区的服务器，它们会缓存资源副本。用户发起请求时，哪个服务器近就由其响应请求。一般存放不需要服务端进行计算，且具有访问频率高，承载流量大的资源，如图片，脚本，样式文件等静态资源。</li><li>合并请求的方案就比较多了。如针对小图标的 <code>CSS sprite</code>、<code>base64</code>、<code>iconfont</code> 等；通过 <code>webpack</code> 等工具将 <code>js</code>、<code>css</code> <strong>打包</strong>成一个文件。但请求不是越少越好，一个大请求的速度不一定快过几个小请求，浏览器能同时发起几个请求，要充分利用这一特点。</li><li>减少请求数量还有 <strong><em>懒加载</em></strong> 和 <strong><em>预加载</em></strong> 的方法。<strong>懒加载</strong> 可以减少首屏的请求数量，如 <code>import()</code>。预加载则可以提高后续的用户体验，如预解析 <code>dns-prefetch</code>，预拉取 <code>prefetch</code>，图片预加载等。<strong><em>懒加载和预加载并不冲突</em></strong>，可以理解为不是马上需要的内容可以懒加载，即将需要的内容可以在浏览器空闲的时候预先加载。</li></ul><h4 id="渲染优化" tabindex="-1"><a class="header-anchor" href="#渲染优化"><span>渲染优化</span></a></h4><ul><li>提到渲染优化就不得不提 <strong>回流和重绘</strong>。批量操作 <code>DOM</code>，动画脱离文档流，<code>requestAnimationFrame</code> 这些方法就不多说了，容易忽略的是获取 <code>offsetLeft</code>， <code>offsetTop</code> 等值的时候也可能引起回流。由于回流成本太高，<strong><em>浏览器会将回流操作用队列存储</em></strong>，当过一段时间或达到某个阈值时清空队列，执行一次回流。但当获取有些值时，浏览器会提前触发回流，以确保获取的值是正确的。</li><li>其次是**<em>非阻塞</em>**。js 文件放 body 底部；<code>&lt;script&gt;</code> 标签的 <code>async</code> 和 <code>defer</code> 属性也是大家熟悉的。</li><li>除此之外，还有针对首屏渲染优化的 <strong><em>服务端渲染 SSR</em></strong>，优化首屏体验的 <strong><em>骨架屏</em></strong> 方案，针对长列表优化的<strong>虚拟列表</strong>等</li></ul><h4 id="js-代码" tabindex="-1"><a class="header-anchor" href="#js-代码"><span>js 代码</span></a></h4><p>代码层面的优化可以说道的很多，但实际上对性能影响很小，可以说是积少成多。除非写出天怒人怨的代码。以下举几个例子：</p><ul><li><p>保存深层变量</p></li><li><p>使用 <code>===</code> 而非<code>==</code>，避免类型转换带来的性能损耗</p></li><li><p>少用 <code>for-in</code></p></li><li><p>使用 <code>if-else</code>、<code>switch</code> 时，将最可能出现的情况放到前面</p></li><li><p>当条件大于（等于）3 个时，使用 <code>switch</code>。而当要判断的离散值数量很大时，使用对象或数据实现查表法</p></li><li><p>尾递归</p></li><li><p>避免改变词法作用域（如 <code>eval</code>，<code>with</code>）</p></li><li><p>减少操作 <code>DOM</code></p></li><li><p>事件委托</p></li><li><p>删除 <code>DOM</code> 节点时，移除其绑定的事件</p></li><li><p>用 JS 实现动画时，应使用 <code>requestAnimationFrame</code></p></li><li><p>防抖和节流</p></li><li><p><code>web worker</code></p><p>在使用框架时，还有针对框架的优化。如 Vue 中 <code>v-for</code> 循环 <code>key</code> 的绑定，<code>Object.freeze</code> 取消不会变更的数据的监听，切分成更小的组件以缩小更新的范围等。以及 React 中 <code>useMemo</code>，<code>useCallback</code> 等缓存钩子的使用</p></li></ul><h3 id="参考文献" tabindex="-1"><a class="header-anchor" href="#参考文献"><span>参考文献</span></a></h3><ul><li><a href="https://github.com/febobo/web-interview/issues/141" target="_blank" rel="noopener noreferrer">https://github.com/febobo/web-interview/issues/141</a></li><li><a href="https://zhuanlan.zhihu.com/p/80551769" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/80551769</a></li></ul>',52)]))}const p=o(a,[["render",d],["__file","after_url.html.vue"]]),s=JSON.parse('{"path":"/http/after_url.html","title":"输入URL后回车分析","lang":"zh-CN","frontmatter":{"title":"输入URL后回车分析","date":"2025-02-26T00:00:00.000Z","article":false,"description":"面试官：说说地址栏输入 URL 敲下回车后发生了什么? 址栏输入 URL址栏输入 URL 一、简单分析 从前端的角度分析，从输入 URL到回车后发生的行为如下： URL 解析 DNS 查询 TCP 连接 HTTP 请求 响应请求 页面渲染 二、详细分析 URL 解析 首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行...","head":[["meta",{"property":"og:url","content":"https://hr-koala.github.io/htblog/htblog/http/after_url.html"}],["meta",{"property":"og:site_name","content":"博客和随笔"}],["meta",{"property":"og:title","content":"输入URL后回车分析"}],["meta",{"property":"og:description","content":"面试官：说说地址栏输入 URL 敲下回车后发生了什么? 址栏输入 URL址栏输入 URL 一、简单分析 从前端的角度分析，从输入 URL到回车后发生的行为如下： URL 解析 DNS 查询 TCP 连接 HTTP 请求 响应请求 页面渲染 二、详细分析 URL 解析 首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:image","content":"https://static.vue-js.com/11bf1f20-bdf4-11eb-85f6-6fac77c0c9b3.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-02-26T12:39:55.000Z"}],["meta",{"property":"article:published_time","content":"2025-02-26T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-02-26T12:39:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"输入URL后回车分析\\",\\"description\\":\\"面试官：说说地址栏输入 URL 敲下回车后发生了什么? 址栏输入 URL址栏输入 URL 一、简单分析 从前端的角度分析，从输入 URL到回车后发生的行为如下： URL 解析 DNS 查询 TCP 连接 HTTP 请求 响应请求 页面渲染 二、详细分析 URL 解析 首先判断你输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行...\\"}"]]},"headers":[{"level":2,"title":"面试官：说说地址栏输入 URL 敲下回车后发生了什么?","slug":"面试官-说说地址栏输入-url-敲下回车后发生了什么","link":"#面试官-说说地址栏输入-url-敲下回车后发生了什么","children":[{"level":3,"title":"一、简单分析","slug":"一、简单分析","link":"#一、简单分析","children":[]},{"level":3,"title":"二、详细分析","slug":"二、详细分析","link":"#二、详细分析","children":[]},{"level":3,"title":"加载优化","slug":"加载优化","link":"#加载优化","children":[]},{"level":3,"title":"参考文献","slug":"参考文献","link":"#参考文献","children":[]}]}],"git":{"createdTime":1740493686000,"updatedTime":1740573595000,"contributors":[{"name":"hr-koala","username":"hr-koala","email":"htong890@outlook.com","commits":2,"url":"https://github.com/hr-koala"}]},"readingTime":{"minutes":6,"words":1800},"filePathRelative":"http/after_url.md","localizedDate":"2025年2月26日","excerpt":"<h2>面试官：说说地址栏输入 URL 敲下回车后发生了什么?</h2>\\n<figure><img src=\\"https://static.vue-js.com/11bf1f20-bdf4-11eb-85f6-6fac77c0c9b3.png\\" alt=\\"址栏输入 URL\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption>址栏输入 URL</figcaption></figure>\\n<h3>一、简单分析</h3>\\n<p>从前端的角度分析，从输入 <code>URL</code>到回车后发生的行为如下：</p>\\n<ul>\\n<li>URL 解析</li>\\n<li>DNS 查询</li>\\n<li>TCP 连接</li>\\n<li>HTTP 请求</li>\\n<li>响应请求</li>\\n<li>页面渲染</li>\\n</ul>","autoDesc":true}');export{p as comp,s as data};
